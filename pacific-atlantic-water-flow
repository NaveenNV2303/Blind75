https://leetcode.com/problems/pacific-atlantic-water-flow/

class Solution {
    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        int m = heights.length;
        int n = heights[0].length;

        boolean[][] pacificCheck = new boolean[m][n];
        boolean[][] atlanticCheck = new boolean[m][n];

        for(int i=0; i<m; i++){
            dfs(pacificCheck, heights, i, 0, heights[i][0] );
            dfs(atlanticCheck, heights, i, n-1, heights[i][n-1] );
        }
        
        for(int j=0; j<n; j++){
            dfs(pacificCheck, heights, 0, j, heights[0][j] );
            dfs(atlanticCheck, heights, m-1, j, heights[m-1][j] );
        }

        List<List<Integer>> result = new ArrayList<>();
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(pacificCheck[i][j] && atlanticCheck[i][j]){
                    List<Integer> currentList = new ArrayList<>();
                    currentList.add(i);
                    currentList.add(j);
                    result.add(currentList);
                }
            }
        }

        return result;
    }

    private void dfs(boolean[][] visited, int[][] heights, int i, int j, int prev){
        if(i < 0 || j < 0 || i >= heights.length || j >= heights[0].length || 
        visited[i][j] || heights[i][j] < prev){
            return;
        }

        visited[i][j] = true;
        dfs(visited, heights, i, j+1, heights[i][j]);
        dfs(visited, heights, i, j-1, heights[i][j]);
        dfs(visited, heights, i+1, j, heights[i][j]);
        dfs(visited, heights, i-1, j, heights[i][j]);

    }
}


// bfs
// class Solution {
//     public List<List<Integer>> pacificAtlantic(int[][] heights) {
//         int m = heights.length;
//         int n = heights[0].length;

//         boolean[][] pacificVisited = new boolean[m][n];
//         boolean[][] atlanticVisited = new boolean[m][n];

//         Queue<int[]> pacificQueue = new LinkedList<>();
//         Queue<int[]> atlanticQueue = new LinkedList<>();

//         // Initialize border cells
//         for (int i = 0; i < m; i++) {
//             pacificQueue.offer(new int[]{i, 0});
//             atlanticQueue.offer(new int[]{i, n - 1});
//             pacificVisited[i][0] = true;
//             atlanticVisited[i][n - 1] = true;
//         }

//         for (int j = 0; j < n; j++) {
//             pacificQueue.offer(new int[]{0, j});
//             atlanticQueue.offer(new int[]{m - 1, j});
//             pacificVisited[0][j] = true;
//             atlanticVisited[m - 1][j] = true;
//         }

//         // Run BFS for each ocean
//         bfs(heights, pacificQueue, pacificVisited);
//         bfs(heights, atlanticQueue, atlanticVisited);

//         // Collect common cells
//         List<List<Integer>> result = new ArrayList<>();
//         for (int i = 0; i < m; i++) {
//             for (int j = 0; j < n; j++) {
//                 if (pacificVisited[i][j] && atlanticVisited[i][j]) {
//                     result.add(Arrays.asList(i, j));
//                 }
//             }
//         }

//         return result;
//     }

//     private void bfs(int[][] heights, Queue<int[]> queue, boolean[][] visited) {
//         int m = heights.length;
//         int n = heights[0].length;
//         int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};

//         while (!queue.isEmpty()) {
//             int[] cell = queue.poll();
//             int x = cell[0], y = cell[1];

//             for (int[] dir : directions) {
//                 int newX = x + dir[0];
//                 int newY = y + dir[1];

//                 if (newX < 0 || newX >= m || newY < 0 || newY >= n 
//                     || visited[newX][newY] 
//                     || heights[newX][newY] < heights[x][y]) {
//                     continue;
//                 }

//                 visited[newX][newY] = true;
//                 queue.offer(new int[]{newX, newY});
//             }
//         }
//     }
// }
