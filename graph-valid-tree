This Question is only for Leetcode Premium. So, I've attached the question here.
https://leetcode.com/problems/graph-valid-tree/

Problem Statement:
You are given an integer n — the number of nodes labeled from 0 to n - 1 — and a list of edges where each edges[i] = [a, b] indicates that there is an undirected edge between node a and node b.
Write a function to determine whether these edges form a valid tree.

Definition of a Valid Tree:
A graph is a valid tree if it satisfies both of the following conditions:
Connected: There is a path between every pair of nodes.
Acyclic: The graph does not contain any cycles.

Output:
Return true if the given edges make up a valid tree.
Otherwise, return false.

Example 1:
Input: n = 5
edges = [[0,1],[0,2],[0,3],[1,4]]
Output:  true

Example 2:
Input: n = 5
edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]
Output: false


Constraints:
n (1 <= n <= 2000): An integer representing the number of nodes.
edges (edges.length <= 5000): A list of undirected edges. Each edge is a pair of integers [a, b] such that 0 <= a, b < n.



Solution:



// for undirected graph
// bfs

class Solution {
    public boolean validTree(int n, int[][] edges) {
        if (edges.length != n - 1) return false;

        List<List<Integer>> adjList = new ArrayList<>();
        for (int i = 0; i < n; i++) adjList.add(new ArrayList<>());
        for (int[] edge : edges) {
            adjList.get(edge[0]).add(edge[1]);
            adjList.get(edge[1]).add(edge[0]);
        }

        boolean[] visited = new boolean[n];
        Queue<int[]> queue = new LinkedList<>(); // [node, parent]
        queue.offer(new int[]{0, -1});
        visited[0] = true;

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int node = current[0];
            int parent = current[1];

            for (int neighbor : adjList.get(node)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.offer(new int[]{neighbor, node});
                } else if (neighbor != parent) {
                    return false; // cycle
                }
            }
        }

        for (boolean v : visited) {
            if (!v) return false;
        }

        return true;
    }
}


// for undirected graph
// dfs


class Solution {
    public boolean validTree(int n, int[][] edges) {
        if (edges.length != n - 1) return false;

        // Build the adjacency list
        List<List<Integer>> adjList = new ArrayList<>();
        for (int i = 0; i < n; i++) adjList.add(new ArrayList<>());
        for (int[] edge : edges) {
            adjList.get(edge[0]).add(edge[1]);
            adjList.get(edge[1]).add(edge[0]); // because undirected
        }

        boolean[] visited = new boolean[n];

        // DFS to detect cycles
        if (hasCycleDFS(0, -1, visited, adjList)) return false;

        // Check if all nodes are visited (graph is connected)
        for (boolean v : visited) {
            if (!v) return false;
        }

        return true;
    }

    private boolean hasCycleDFS(int node, int parent, boolean[] visited, List<List<Integer>> adjList) {
        visited[node] = true;
        for (int neighbor : adjList.get(node)) {
            if (!visited[neighbor]) {
                if (hasCycleDFS(neighbor, node, visited, adjList)) return true;
            } else if (neighbor != parent) {
                // Cycle detected
                return true;
            }
        }
        return false;
    }
}



//for directed graph

class ValidGraph{
	public boolean isItValid(int n, int[][] nodes){
		List<List<Integer>> adjList= new ArrayList<>();
		for(int i=0; i<n; i++){
			adjList.add(new ArrayList<>());
}

Queue<Integer> queue = new LinkedList<>();
boolean[] visited = new boolean[n];
int[] inDegree = new int[n];

for(int [] node: nodes){
	int a = node[0];
	int b = node[1];
	adjList.get(a).add(b);
	inDegree[b]++;
}

int componentCheck = 0;
for(int i=0; i<n; i++){
	if(inDegree[i] == 0){
	queue.add(i);
	componentCheck++;
}
}

if(componentCheck > 1) return false;

while(!queue.isEmpty()){
	int current = queue.poll();
	if(visited[current ]){
	return false;
}
Visited[current] = true;
	for(int neighbour: adjList.get(current)){
	inDegree[neighbour]--;
	if(inDegree[neighbour] == 0){
	queue.add(neighbour);
}
}
}

for(boolean isItValid: visited){
	if(!isItValid) return false;
}
return true;
}
}
