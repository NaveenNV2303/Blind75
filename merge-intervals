https://leetcode.com/problems/merge-intervals/

class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(a,b) -> a[0] - b[0]);
        int n = intervals.length;
        List<int[]> result = new ArrayList<>();
        int i = 0;
        while(i<n){
            int[] newArr = intervals[i];
            while(i<n-1 && newArr[1] >= intervals[i+1][0]){
                newArr[0] = Math.min(newArr[0], intervals[i+1][0]);
                newArr[1] = Math.max(newArr[1], intervals[i+1][1]);
                i++;
            }
            result.add(newArr);
            i++;
        }
        return result.toArray(new int[result.size()][]);
    }
}
// Additional hints to sorting the 2D array.
//     Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
//     Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]).reversed());
//     Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

// intervals.sort((a, b) -> Integer.compare(a.get(0), b.get(0)));
// intervals.sort(Comparator.comparingInt(a -> a.get(0)));
// intervals.sort(Comparator.comparingInt((List<Integer> a) -> a.get(0)).reversed());



// class IntervalComparator implements Comparator<List<Integer>> {
//     public int compare(List<Integer> a, List<Integer> b) {
//         if (!a.get(0).equals(b.get(0))) {
//             return a.get(0) - b.get(0);  // Ascending by start
//         }
//         // Custom logic: e.g., descending by end
//         return b.get(1) - a.get(1);
//     }
// }

// // Usage:
// intervals.sort(new IntervalComparator());


// intervals.sort((a, b) -> {
//     if (a.get(0).equals(b.get(0))) {
//         if (a.get(1) < b.get(1)) {
//             return -1;
//         } else if (a.get(1) > b.get(1)) {
//             return 1;
//         } else {
//             return 0;
//         }
//     } else {
//         return a.get(0) - b.get(0);
//     }
// });
